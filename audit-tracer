"""
Core AuditTracer implementation for LLM interaction auditing.
This module provides the main interface for cryptographic auditing of LLM agent
interactions, with support for compliance standards and tamper-proof logging.
Author: David Hassoun
Copyright (c) 2025 David Hassoun
"""
import time
import json
import uuid
import sqlite3
import threading
from typing import Dict, Any, Optional, List, Tuple
from pathlib import Path
from .crypto_engine import CryptoEngine
from .replay_engine import ReplayEngine
from .compliance_manager import ComplianceManager


class AuditTracer:
    """Main interface for cryptographic auditing of LLM agent interactions."""
    
    def __init__(
        self,
        session_id: Optional[str] = None,
        storage_path: str = "./audit_logs",
        compliance_mode: Optional[str] = None,
        retention_years: int = 3,
        crypto_key: Optional[str] = None
    ):
        """
        Initialize AuditTracer with compliance configuration.
        
        Args:
            session_id: Unique session identifier
            storage_path: Directory for audit log storage
            compliance_mode: "medical", "financial", or "general"
            retention_years: Data retention period
            crypto_key: Custom cryptographic key (auto-generated if None)
        """
        self.session_id = session_id or str(uuid.uuid4())
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(parents=True, exist_ok=True)
        self.compliance_mode = compliance_mode
        self.retention_years = retention_years
        
        # Initialize core components
        self.crypto_engine = CryptoEngine(crypto_key=crypto_key)
        self.compliance_manager = ComplianceManager(compliance_mode)
        
        # Database connection
        self.db_path = self.storage_path / f"{self.session_id}.db"
        self._init_database()
        
        # Thread safety
        self._lock = threading.RLock()
        self._active_session = False

    def _init_database(self):
        """Initialize SQLite database for audit storage."""
        conn = sqlite3.connect(str(self.db_path))
        conn.execute('''
            CREATE TABLE IF NOT EXISTS audit_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_id TEXT UNIQUE NOT NULL,
                session_id TEXT NOT NULL,
                timestamp REAL NOT NULL,
                event_type TEXT NOT NULL,
                data TEXT NOT NULL,
                hash TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        conn.commit()
        conn.close()

    def wrap_client(self, client):
        """Wrap LLM client to enable automatic interaction tracing."""
        if hasattr(client, 'chat') and hasattr(client.chat, 'completions'):
            return OpenAIInterceptor(client, self)
        else:
            raise ValueError(f"Unsupported client type: {type(client)}")

    def audit_session(self):
        """Context manager for audit session lifecycle."""
        return AuditSessionContext(self)

    def log_event(self, event_type: str, data: Dict[str, Any]) -> str:
        """Log event with cryptographic hash for integrity verification."""
        with self._lock:
            event = {
                "event_id": str(uuid.uuid4()),
                "session_id": self.session_id,
                "timestamp": time.time(),
                "event_type": event_type,
                "data": data
            }
            
            # Generate cryptographic hash
            event_hash = self.crypto_engine.hash_event(event)
            event["hash"] = event_hash
            
            # Store in database
            conn = sqlite3.connect(str(self.db_path))
            conn.execute('''
                INSERT INTO audit_events
                (event_id, session_id, timestamp, event_type, data, hash)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (
                event["event_id"],
                event["session_id"],
                event["timestamp"],
                event["event_type"],
                json.dumps(event["data"]),
                event["hash"]
            ))
            conn.commit()
            conn.close()
            
            return event["event_id"]

    def log_llm_interaction(
        self,
        provider: str,
        model: str,
        messages: List[Dict],
        response: Dict,
        metadata: Optional[Dict] = None
    ) -> str:
        """Log LLM API interaction with complete context."""
        interaction_data = {
            "provider": provider,
            "model": model,
            "messages": messages,
            "response": response,
            "token_usage": response.get("usage", {}),
            "latency_ms": metadata.get("latency_ms", 0) if metadata else 0,
            "compliance_metadata": self.compliance_manager.get_interaction_metadata()
        }
        return self.log_event("llm_interaction", interaction_data)

    def export_compliance_report(self) -> Dict[str, Any]:
        """Export comprehensive audit trail for compliance reporting."""
        events = self._get_all_events()
        
        # Verify cryptographic integrity
        integrity_valid, verification_details = self.verify_integrity()
        
        # Generate compliance-specific metadata
        compliance_metadata = self.compliance_manager.generate_report_metadata(
            events, self.retention_years
        )
        
        return {
            "session_id": self.session_id,
            "export_timestamp": time.time(),
            "total_events": len(events),
            "integrity_verified": integrity_valid,
            "verification_details": verification_details,
            "compliance_metadata": compliance_metadata,
            "events": events,
            "framework_info": {
                "name": "LLMAuditTrail",
                "version": "0.1.0",
                "author": "David Hassoun"
            }
        }

    def verify_integrity(self) -> Tuple[bool, Dict[str, Any]]:
        """Verify cryptographic integrity of complete audit trail."""
        events = self._get_all_events()
        if not events:
            return True, {"message": "No events to verify"}
        
        verification_results = []
        for event in events:
            # Reconstruct event without hash for verification
            event_data = {
                "event_id": event["event_id"],
                "session_id": event["session_id"],
                "timestamp": event["timestamp"],
                "event_type": event["event_type"],
                "data": json.loads(event["data"]) if isinstance(event["data"], str) else event["data"]
            }
            
            expected_hash = self.crypto_engine.hash_event(event_data)
            is_valid = event["hash"] == expected_hash
            
            verification_results.append({
                "event_id": event["event_id"],
                "hash_valid": is_valid,
                "timestamp": event["timestamp"]
            })
        
        all_valid = all(result["hash_valid"] for result in verification_results)
        
        # Calculate Merkle root for additional verification
        event_hashes = [event["hash"] for event in events]
        merkle_root = self.crypto_engine.calculate_merkle_root(event_hashes)
        
        return all_valid, {
            "total_events": len(events),
            "valid_events": sum(1 for r in verification_results if r["hash_valid"]),
            "verification_results": verification_results,
            "merkle_root": merkle_root,
            "crypto_algorithm": "HMAC-SHA256"
        }

    def create_replay_engine(self, target_session_id: Optional[str] = None) -> ReplayEngine:
        """Create replay engine for session analysis."""
        session_id = target_session_id or self.session_id
        events = self._get_all_events(session_id)
        return ReplayEngine(events, self.crypto_engine)

    def _get_all_events(self, session_id: Optional[str] = None) -> List[Dict]:
        """Retrieve all events for specified session."""
        target_session = session_id or self.session_id
        conn = sqlite3.connect(str(self.db_path))
        conn.row_factory = sqlite3.Row
        cursor = conn.execute(
            'SELECT * FROM audit_events WHERE session_id = ? ORDER BY timestamp',
            (target_session,)
        )
        events = [dict(row) for row in cursor.fetchall()]
        conn.close()
        return events


class AuditSessionContext:
    """Context manager for audit session lifecycle."""
    
    def __init__(self, tracer: AuditTracer):
        self.tracer = tracer
        self.start_time = None

    def __enter__(self):
        self.tracer._active_session = True
        self.start_time = time.time()
        self.tracer.log_event("session_start", {
            "compliance_mode": self.tracer.compliance_mode,
            "retention_years": self.tracer.retention_years,
            "framework_author": "David Hassoun"
        })
        return self.tracer

    def __exit__(self, exc_type, exc_val, exc_tb):
        duration = time.time() - self.start_time
        self.tracer.log_event("session_end", {
            "duration_seconds": duration,
            "exception_occurred": exc_type is not None,
            "total_events": len(self.tracer._get_all_events())
        })
        self.tracer._active_session = False


class OpenAIInterceptor:
    """Transparent interceptor for OpenAI client API calls."""
    
    def __init__(self, client, tracer: AuditTracer):
        self._client = client
        self._tracer = tracer
        
        # Preserve original client interface
        for attr in dir(client):
            if not attr.startswith('_') and attr != 'chat':
                setattr(self, attr, getattr(client, attr))
        
        # Wrap chat completions
        self.chat = ChatCompletionsWrapper(client.chat, tracer)


class ChatCompletionsWrapper:
    """Wrapper for OpenAI chat completions with audit logging."""
    
    def __init__(self, chat, tracer):
        self._chat = chat
        self._tracer = tracer
        
        # Preserve original interface
        for attr in dir(chat):
            if not attr.startswith('_') and attr != 'completions':
                setattr(self, attr, getattr(chat, attr))
        
        self.completions = CompletionsWrapper(chat.completions, tracer)


class CompletionsWrapper:
    """Wrapper for OpenAI completions with full audit trail."""
    
    def __init__(self, completions, tracer):
        self._completions = completions
        self._tracer = tracer

    def create(self, **kwargs):
        """Intercept and log completion creation."""
        start_time = time.time()
        
        try:
            # Call original API
            response = self._completions.create(**kwargs)
            
            # Calculate latency
            latency_ms = (time.time() - start_time) * 1000
            
            # Log interaction
            self._tracer.log_llm_interaction(
                provider="openai",
                model=kwargs.get("model", "unknown"),
                messages=kwargs.get("messages", []),
                response=response.model_dump() if hasattr(response, 'model_dump') else dict(response),
                metadata={"latency_ms": latency_ms}
            )
            
            return response
            
        except Exception as e:
            # Log error
            self._tracer.log_event("llm_error", {
                "provider": "openai",
                "model": kwargs.get("model", "unknown"),
                "error": str(e),
                "latency_ms": (time.time() - start_time) * 1000
            })
            raise
